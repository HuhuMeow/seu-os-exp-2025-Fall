\newpage
\section{shell}
\begin{quote}
The shell is an ordinary program that reads commands from the user and executes them. The fact that the shell is a user program, and not part of the kernel, illustrates the power of the system call interface: there is nothing special about the shell. It also means that the shell is easy to replace; as a result, modern Unix systems have a variety of shells to choose from, each with its own user interface and scripting features.\\
shell 只是一个普通程序,负责读取并执行用户命令。正因为 shell 是用户程序而非内核的一部分,才凸显出系统调用接口的强大——shell 本身并无特殊之处。这也使得 shell 可以轻松替换;现代 Unix 系统正是如此,提供了多种 shell,各自拥有不同的用户界面和脚本功能。
\par \hfill --xv6: a simple, Unix-like teaching operating system
\end{quote}
\begin{quote}
The shell is a command-line interpreter that prints a prompt, waits for you to type a command line, and then performs the command. If the first word of the command line does not correspond to a built-in shell command, then the shell assumes that it is the name of an executable file that it should load and run.\\
shell 是一个命令行解释器，它会显示提示符，等待用户输入命令行，然后执行该命令。如果命令行的第一个单词不是内置的 shell 命令，shell 就会将其视为可执行文件的名称，并加载运行该文件。
\par \hfill --Computer Systems: A Programmer's Perspective
\end{quote}
\subsection{实验内容}
实现具有\textbf{管道、重定向功能}的\texttt{shell}，能够执行一些简单的基本命令，如进程执行、列目录等
\subsection{具体要求}
\begin{itemize}
  \item 设计一个\texttt{rust}语言程序\footnote{课程原本要求为C语言，但既然我们已经踏上了\texttt{Arch Linux}这条贼船，使用\texttt{rust}也是在情理之中的。}，完成最基本的\texttt{shell}角色：给出命令行提示符、能够逐次接受命令。
对于命令分成三种
\begin{itemize}
  \item 内部命令（例如\texttt{help}命令、\texttt{exit}命令等）
  \item 外部命令（常见的\texttt{ls}、\texttt{cp}等，以及其他磁盘上的可执行程序\texttt{HelloWorld}等）
  \item 无效命令（不是上述二种命令）
\end{itemize}
\item 具有支持管道的功能，即在\texttt{shell}中输入诸如``\texttt{dir | more}''能够执行\texttt{dir}命令并将其输出通过管道将其输入传送给\texttt{more}。
\item 具有支持重定向的功能，即在\texttt{shell}中输入诸如``\texttt{dir > direct.txt}''能够执行\texttt{dir}命令并将结果输出到\texttt{direct.txt}
\item 将上述步骤直接合并完成
\end{itemize}
\subsection{环境配置}
在\texttt{Arch Linux}上配置\texttt{rust}开发环境只需两行
\begin{lstlisting}
sudo pacman -S rustup
rustup default stable
\end{lstlisting}
可通过以下命令确认是否安装成功：
\begin{lstlisting}
rustc --version
cargo --version
\end{lstlisting}
用\texttt{cargo}创建项目:
\begin{lstlisting}
$ cargo new mysh
$ cd mysh
\end{lstlisting}
在\texttt{mysh/src}目录下有一\texttt{main.rs}文件，对于我们的第一个版本的\texttt{shell}，编辑这个文件就可以了。
\input{chapters/lstlisting-code/shell_ver1.tex}
\par 这个版本的 \texttt{shell} 能够\textbf{处理内部命令和外部命令}，但受限于简单的查找逻辑，暂时还无法执行磁盘上不在 \texttt{PATH} 路径内的程序（如显式指定相对路径 \texttt{./main}）。 
\par \texttt{Rust} 的 \texttt{std::process::Command} 封装遮蔽了底层的复杂性：它会自动在 \texttt{PATH} 中搜索程序，并通过 \texttt{posix\_spawn} 或 \texttt{fork/exec} 组合来执行程序。在这个高层抽象下，开发者无需手动管理 \texttt{fork} 后的内存布局，也不必显式处理文件描述符（FD）的继承与关闭。而在 \texttt{C} 语言视角下，这个过程是完全手动的:
\par 当 \texttt{shell} 决定执行一个外部程序时，它首先调用 \texttt{fork}。此时，子进程完全\textbf{克隆}了父进程（Shell）的 \texttt{task\_struct}，因此继承了完全一致的内存镜像（包含 \texttt{PATH} 变量）和文件描述符表（\texttt{files\_struct}）。 \par 随后，子进程调用 \texttt{exec} 系统调用（如 \texttt{execve}）。\texttt{exec} 会彻底销毁子进程原有的用户内存空间（栈、堆、代码段）。这意味着原有的 \texttt{PATH} 变量也会随之消失。因此，\texttt{shell} 必须在调用 \texttt{execve} 时，将 \texttt{PATH} 等环境变量作为参数（\texttt{envp}）显式\textbf{传递}给内核。内核会将这些数据搬运到新程序的栈顶。 与内存不同，内核默认\textbf{保留}子进程的文件描述符表（除非设置了 \texttt{FD\_CLOEXEC}）。这一特性至关重要：它允许 \texttt{shell} 在 \texttt{exec} 之前通过 \texttt{dup2} 调整标准输入输出指向（重定向），而新程序在完全不知情的情况下，自然继承这些指向文件或管道的文件描述符 ，从而实现 \texttt{I/O} 流的无缝衔接。
