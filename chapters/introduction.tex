%% introduction.tex 
%% ------------------
%% Author: HuhuMeow (Huhu_Miao)
%% License: MIT
\section{实验环境简述}
\par 本次实验采用\texttt{Arch Linux ARM aarch64}，内核版本为{Linux 6.18.0-1-aarch64-ARCH}\footnote{6.18版本的内核在2025年11月30日被确认为LTS版本，会支持到2027年12月。}。虚拟机版本为VMware Fusion 13.6.4。
\par 我注意到，在\texttt{archinstall}的帮助下，Arch Linux 的安装并不比其他发行版更难。由于 Arch Linux 的轻量化，它在虚拟机中的启动速度也令我满意，这对于需要频繁重启的实验场景友好。出于以上原因，我选择了 Arch Linux 。
\section{Linux进程管理及其扩展}
\subsection{实验内容}
\par 实现一个系统调用\texttt{hide}，使得可以根据指定的参数隐藏进程，使用户无法使用\texttt{ps}或\texttt{top}观察到进程状态。
\subsection{具体要求}
\begin{enumerate}
	\item 实现系统调用\texttt{int hide(pid\_t pid, int on)}，在进程\texttt{pid}有效的前提下，如果\texttt{on}置\texttt{1}，进程被隐藏，用户无法通过\texttt{ps}或\texttt{top}观察到进程状态；如果\texttt{on}置\texttt{0}且此前为隐藏状态，则恢复正常状态。
	\item 考虑权限问题，只有\texttt{root}用户才能隐藏进程。 
	\item 设计一个新的系统调用\texttt{int hide\_user\_processes(uid\_t uid, char *binname)}，参数\texttt{uid}为用户ID号，当\texttt{binname}参数为\texttt{NULL}时，隐藏该用户的所有进程；否则，隐藏二进制映像名为\texttt{binname}的用户进程。该系统调用应与\texttt{hide}系统调用共存。
	\item 在\texttt{/proc}目录下创建一个文件\texttt{/proc/hidden}，该文件可读可写，对应一个全局变量\texttt{hidden\_flag}，当\texttt{hidden\_flag}为0时，所有进程都无法隐藏，即便此前进程被\texttt{hide}系统调用要求隐藏。只有当\texttt{hidden\_flag}为1时，此前通过\texttt{hide}调用要求被屏蔽的进程才隐藏起来
	\item 在\texttt{/proc}目录下创建一个文件\texttt{/proc/hidden\_process}，该文件的内容包含所有被隐藏进程的\texttt{pid}，各\texttt{pid}之间用空格分开
\end{enumerate}
\newpage
\subsection{实验过程}
\subsubsection{实现系统调用\texttt{hide}}
\par 首先，下载内核源码并解压到相应目录。然后修改文件。
\begin{lstlisting}
~/linux-6.18 % vim include/linux/sched.h
\end{lstlisting}
\par 跳转到此文件的第819行，从这行开始是结构体\texttt{task\_struct}的定义，我们跳转到定义的最后(1656行)，在这里添加\texttt{hide\_flag}(1660)。
\input{chapters/lstlisting-code/add_hide_flag.tex}
修改完\texttt{task\_struct}后，再修改\texttt{fork.c}。
\begin{lstlisting}
~/linux-6.18 % vim kernel/fork.c
\end{lstlisting}
修改此文件在1916行开始定义的\texttt{copy\_process}函数，添加一行代码初始化\texttt{hide\_flag}，确保所有的子进程默认是不隐藏的。
\begin{lstlisting}[firstnumber=2012]
	p = dup_task_struct(current, node);
	if (!p)
		goto fork_out;
	
		(*@\textcolor{mygreen}{p->hide\_flag = 0;}@*)

	p->flags &= ~PF_KTHREAD;
	if (args->kthread)
		p->flags |= PF_KTHREAD;
\end{lstlisting}
\begin{lstlisting}
~/linux-6.18 % vim kernel/sys.c
\end{lstlisting}
\input{chapters/lstlisting-code/sys_hide_code.tex}
\begin{lstlisting}
~/linux-6.18 % vim fs/readdir.c
\end{lstlisting}
\begin{lstlisting}
/* --- fs/readdir.c 头部新增/确认引用 --- */
#include <linux/ctype.h>   // 用于 isdigit
#include <linux/sched.h>   // 用于 task_struct, find_task_by_vpid
\end{lstlisting}
\input{chapters/lstlisting-code/getdents64.tex}
\par 在\texttt{include/linux/syscalls.h}的倒数第二行，也就是在 \texttt{\#endif} 之前， 添加声明\texttt{asmlinkage long sys\_hide(pid\_t pid, int on);}
\begin{lstlisting}[firstnumber = 411 , caption = {在\texttt{scripts/syscall.tbl}中注册系统调用号}]
468	common	file_getattr			sys_file_getattr
469	common	file_setattr			sys_file_setattr
(*@\textcolor{mygreen}{{470\hspace{3.39em}common\hspace{1.85em}hide\hspace{17.15em}sys\_hide}}@*)
\end{lstlisting}
\input{chapters/lstlisting-code/compile_kernel.tex}
\begin{lstlisting}[caption = {/etc/mkinitcpio.d/linux-custom.preset}]
ALL_kver="6.18.0-ARCH" # 这行是不可以随便填的，应该与前文ls /lib/modules/的输出结果对齐

PRESETS=('default')

# 生成名为 initramfs-linux-custom.img 的文件
default_image="/boot/initramfs-linux-custom.img"
default_options=""
\end{lstlisting}
\input{chapters/lstlisting-code/hide_tool_code.tex}
\input{chapters/lstlisting-code/test_sys_hide.tex}
\subsection{实现系统调用\texttt{hide\_user\_processes}}
