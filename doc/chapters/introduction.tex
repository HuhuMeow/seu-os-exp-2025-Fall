%% introduction.tex 
%% ------------------
%% Author: HuhuMeow (Huhu_Miao)
%% License: MIT
\newcommand{\sysc}{\texttt{kernel/sys.c}}
\newcommand{\syscallh}{\texttt{include/linux/syscall.h}}
\newcommand{\syscalltbl}{\texttt{scripts/syscall.tbl}}
\section{实验环境简述}
\par 本次实验采用\texttt{Arch Linux ARM aarch64}，内核版本为{Linux 6.18.0-1-aarch64-ARCH}\footnote{6.18版本的内核在2025年11月30日被确认为LTS版本，会支持到2027年12月。}。虚拟机版本为VMware Fusion 13.6.4。
\par 我注意到，在\texttt{archinstall}的帮助下，Arch Linux 的安装并不比其他发行版更难。由于 Arch Linux 的轻量化，它在虚拟机中的启动速度也令我满意，这对于需要频繁重启的实验场景友好。出于以上原因，我选择了 Arch Linux 。
\section{Linux进程管理及其扩展}
\subsection{实验内容}
\par 实现一个系统调用\texttt{hide}，使得可以根据指定的参数隐藏进程，使用户无法使用\texttt{ps}或\texttt{top}观察到进程状态。
\subsection{具体要求}
\begin{enumerate}
	\item 实现系统调用\texttt{int hide(pid\_t pid, int on)}，在进程\texttt{pid}有效的前提下，如果\texttt{on}置\texttt{1}，进程被隐藏，用户无法通过\texttt{ps}或\texttt{top}观察到进程状态；如果\texttt{on}置\texttt{0}且此前为隐藏状态，则恢复正常状态。
	\item 考虑权限问题，只有\texttt{root}用户才能隐藏进程。 
	\item 设计一个新的系统调用\texttt{int hide\_user\_processes(uid\_t uid, char *binname)}，参数\texttt{uid}为用户ID号，当\texttt{binname}参数为\texttt{NULL}时，隐藏该用户的所有进程；否则，隐藏二进制映像名为\texttt{binname}的用户进程。该系统调用应与\texttt{hide}系统调用共存。
  \item 在\texttt{/proc}目录下创建一个文件\texttt{/proc/hidden}，该文件可读可写，对应一个全局变量\texttt{hidden\_flag}，当\texttt{hidden\_flag}为0时，所有进程都无法隐藏，即便此前进程被\texttt{hide}系统调用要求隐藏。只有当\texttt{hidden\_flag}为1时，此前通过\texttt{hide}调用要求被屏蔽的进程才隐藏起来
	\item 在\texttt{/proc}目录下创建一个文件\texttt{/proc/hidden\_process}，该文件的内容包含所有被隐藏进程的\texttt{pid}，各\texttt{pid}之间用空格分开
\end{enumerate}
\newpage
\subsection{实现系统调用\texttt{hide}}
\par 首先要明确，添加一个系统调用可以分为三个部分：函数实现、添加函数声明、注册系统调用号。其中，添加函数实现需要修改\texttt{kernel/sys.c}，添加函数声明需要修改\texttt{include/linux/syscall.h}，注册系统调用号需要修改\texttt{scripts/syscall.tbl}\footnote{这部分内容与指导手册有较大出入，因为自内核版本6.11开始，ARM架构下注册系统调用号的方式发生了变更，相关内容可以在文档\texttt{Documentation/process/adding-syscalls.rst}中查到}。
\par 首先，下载内核源码并解压到相应目录。然后修改文件。
\begin{lstlisting}
~/linux-6.18 % vim include/linux/sched.h
\end{lstlisting}
\par 跳转到此文件的第819行，从这行开始是结构体\texttt{task\_struct}的定义，我们跳转到定义的最后(1656行)，在这里添加\texttt{hide\_flag}(1660)。
\input{chapters/lstlisting-code/add_hide_flag.tex}
修改完\texttt{task\_struct}后，再修改\texttt{fork.c}。
\begin{lstlisting}
~/linux-6.18 % vim kernel/fork.c
\end{lstlisting}
修改此文件在1916行开始定义的\texttt{copy\_process}函数，添加一行代码初始化\texttt{hide\_flag}，确保所有的子进程默认是不隐藏的。
\begin{lstlisting}[firstnumber=2012]
	p = dup_task_struct(current, node);
	if (!p)
		goto fork_out;
	
		(*@\textcolor{mygreen}{p->hide\_flag = 0;}@*)

	p->flags &= ~PF_KTHREAD;
	if (args->kthread)
		p->flags |= PF_KTHREAD;
\end{lstlisting}
\begin{lstlisting}
~/linux-6.18 % vim kernel/sys.c
\end{lstlisting}
\input{chapters/lstlisting-code/sys_hide_code.tex}
\begin{lstlisting}
~/linux-6.18 % vim fs/readdir.c
\end{lstlisting}
\begin{lstlisting}
/* --- fs/readdir.c 头部新增/确认引用 --- */
#include <linux/ctype.h>   // 用于 isdigit
#include <linux/sched.h>   // 用于 task_struct, find_task_by_vpid
\end{lstlisting}

\newpage
\input{chapters/lstlisting-code/getdents64.tex} % 修改 fs/readdir.c 中的 getdents64 系统调用

\par 在\texttt{include/linux/syscalls.h}的倒数第二行，也就是在 \texttt{\#endif} 之前， 添加函数声明\texttt{asmlinkage long sys\_hide(pid\_t pid, int on);}
\begin{lstlisting}[firstnumber = 411 , caption = {在\texttt{scripts/syscall.tbl}中注册系统调用号}]
468	common	file_getattr			sys_file_getattr
469	common	file_setattr			sys_file_setattr
(*@\textcolor{mygreen}{{470\hspace{3.39em}common\hspace{1.85em}hide\hspace{17.15em}sys\_hide}}@*)
\end{lstlisting}
\input{chapters/lstlisting-code/compile_kernel.tex}

\newpage
\begin{lstlisting}[caption = {/etc/mkinitcpio.d/linux-custom.preset}]
ALL_kver="6.18.0-ARCH" 
# 上面这行是不可以随便填的，应该与前文ls /lib/modules/的输出结果对齐

PRESETS=('default')

# 生成名为 initramfs-linux-custom.img 的文件
default_image="/boot/initramfs-linux-custom.img"
default_options=""
\end{lstlisting}
\input{chapters/lstlisting-code/hide_tool_code.tex}
\input{chapters/lstlisting-code/test_sys_hide.tex}
\subsection{实现系统调用\texttt{hide\_user\_processes}}
\par 在内核6.18中，\texttt{task\_struct} 中有一个指向 \texttt{struct cred}（该结构体定义可见附录代码\ref{cred}） 的指针。在\texttt{cred}结构体中，有字段\texttt{const struct cred \_\_rcu *real\_cred}保存了进程创建者的\texttt{uid}。
\subsubsection{修改\sysc ，添加函数实现}
\par 确保\sysc 包含以下头文件，然后在此文件中添加\texttt{hide\_user\_process}的定义。值得指出的是，在 Linux 内核开发中，\textbf{绝对禁止}直接解引用用户态传入的指针。必须用\texttt{copy\_from\_user}、\texttt{strncpy\_from\_user} 或 \texttt{get\_user}等专用函数，将数据从用户空间拷贝到内核栈。
\begin{lstlisting}
#include <linux/sched/signal.h> // for_each_process
#include <linux/string.h>       // strcmp
#include <linux/uaccess.h>      // strncpy_from_user
#include <linux/cred.h>         // uid_eq, current_user_ns
\end{lstlisting}
\newpage
\input{chapters/lstlisting-code/hide_user_process_code.tex} % hide_user_process
\subsubsection{修改\syscallh ，添加函数声明}
\par 添加函数声明\texttt{asmlinkage long sys\_hide\_user\_processes(uid\_t uid, char \_\_user *binname);}
\subsubsection{修改\syscalltbl，注册系统调用号}
\begin{lstlisting}
470	common	hide				sys_hide
471	common	hide_user_processes		sys_hide_user_processes
\end{lstlisting}
\subsubsection{编译并安装新的内核}
\par 由于我们只修改了\sysc ，并没有对驱动做任何修改，所以只需要编译\texttt{Image}，而后把编译结果拷贝进\texttt{/boot}即可
\input{chapters/lstlisting-code/compile_kernel2.tex}
\subsubsection{测试系统调用\texttt{hide\_user\_processes}}
\input{chapters/lstlisting-code/hide_user_tool.tex}
\input{chapters/lstlisting-code/test_sys_hide_user_processes.tex}
\subsection{添加全局变量\texttt{hidden\_flag}}
\par 在\texttt{fs/readdir.c}中声明外部全局变量\texttt{extern int hidden\_flag}，同时修改\texttt{getdents64}系统调用的逻辑，将我们加入的代码开头的 \texttt{if (error > 0)} 修改为 \texttt{if (error > 0 \&\& hidden\_flag == 1)}
\par 然后，在\sysc 中添加全局变量\texttt{int hidden\_flag = 0;}, 在文件末尾追加以下代码：
\input{chapters/lstlisting-code/hidden_flag_code.tex}
\par 其中\texttt{EXPORT\_SYMBOL}将符号导出到内核符号表，主要用于让模块（.ko）能访问这个符号（运行时链接）。\texttt{extern}声明则是告诉编译器这个变量在其他编译单元中定义。
\input{chapters/lstlisting-code/hiddenc.tex}
\par 修改\texttt{fs/proc/Makefile}:
\newpage
\begin{lstlisting}
# fs/proc/Makefile
# 找到 obj-y 那一行，添加 hidden.o
obj-y += hidden.o
\end{lstlisting}
\begin{lstlisting}
~/linux-6.18 % make -j$(nproc) Image
~/linux-6.18 % sudo cp arch/arm64/boot/Image /boot/vmlinuz-linux-custom
# reboot
\end{lstlisting}
\input{chapters/lstlisting-code/result_hidden_flag.tex}
\subsection{创建文件\texttt{/proc/hidden\_process}}
\par 在内核代码中创建并修改文件\texttt{fs/proc/hidden\_process}，而后修改\texttt{fs/proc/Makefile} , 添加\texttt{obj-y += hidden\_process.o}。
\input{chapters/lstlisting-code/hiddenprocessc.tex}
\begin{lstlisting}
~/linux-6.18 % make -j$(nproc) Image
~/linux-6.18 % sudo cp arch/arm64/boot/Image /boot/vmlinuz-linux-custom
# reboot
\end{lstlisting}
\input{chapters/lstlisting-code/result_hidden_process.tex}
